        -:    0:Source:velha.cpp
        -:    1:/* Copyright [2024] <Copyright Ryan>
        -:    2: * \file  velha.cpp
        -:    3: */
        -:    4:#include "velha.hpp"
        -:    5:/**
        -:    6: * @brief verifica situacao do jogo da velha  
        -:    7: * @author Ryan Reis
        -:    8: * @param  velha - verifica se X venceu, ou se é impossível pelas regras;
        -:    9: */ 
        -:   10:
        6:   11:bool VerificaRegras(int velha[3][3]) {
        6:   12:    int primeiro = velha[0][0];
        6:   13:    if (primeiro != 1 && primeiro != 2) {
    #####:   14:        return false;
        -:   15:    }
       12:   16:    for (int i=0; i <= 2; i++) {
       35:   17:        for (int j=0; j <= 2; j++) {
       29:   18:            if (velha[i][j] != primeiro && velha[i][j] != 0) {
        4:   19:                return false;
        -:   20:            }
        -:   21:        }
        -:   22:    }
        -:   23:
        2:   24:    return true;
        -:   25:}
        -:   26:
        6:   27:bool VerificaEmpate(int velha[3][3]) {
        6:   28:    int quantX = 0;
        6:   29:    int quantO = 0;
        -:   30:
       24:   31:    for (int i=0; i <= 2; i++) {
       72:   32:        for (int j=0; j <= 2; j++) {
       54:   33:            if (velha[i][j] == 1) {
       20:   34:                quantX += 1;
        -:   35:            }
       54:   36:            if (velha[i][j] == 2) {
       10:   37:                quantO += 1;
        -:   38:            }
        -:   39:        }
        -:   40:    }
        6:   41:    if ((quantX == quantO) && (quantX > 0) && (quantX <= 2)) {
        2:   42:        return true;
        -:   43:    }
        4:   44:    return false;
        -:   45:}
        -:   46:
        9:   47:bool VerificaIndefinido(int velha[3][3]) {
        9:   48:    int quantX = 0;
        9:   49:    int quantO = 0;
        -:   50:    // Conta os elementos no tabuleiro
       36:   51:    for (int i = 0; i <= 2; i++) {
      108:   52:        for (int j = 0; j <= 2; j++) {
       81:   53:            if (velha[i][j] == 1) {
       28:   54:                quantX += 1;
       53:   55:            } else if (velha[i][j] == 2) {
       15:   56:                quantO += 1;
        -:   57:            }
        -:   58:        }
        -:   59:    }
        9:   60:    if ((quantX > 3 || quantO > 3) && (VerificaRegras(velha) == false)) {
        1:   61:        return true;
        -:   62:    }
        8:   63:    if (((quantX == 0 || quantO == 0) || (quantX < 3 && quantO < 3 && quantX != quantO)) && (quantO != 9 && quantX != 9)) {
        2:   64:        return true;
        -:   65:    }
        -:   66:
        6:   67:    return false;
        -:   68:}
        -:   69:
        9:   70:int VerificaVelha(int velha[3][3]) {
        -:   71:    /* Verifica se o estado do tabuleiro é indefinido */
        9:   72:    if (VerificaIndefinido(velha)) {
        3:   73:        return -1;
        -:   74:    }
        -:   75:    /* Verifica a existência de empates */
        6:   76:    if (VerificaEmpate(velha)) {
        2:   77:        return 0;
        -:   78:    }
        -:   79:    /* Verifica as regras */
        4:   80:    if (VerificaRegras(velha)) {
        1:   81:        return -2;
        -:   82:    }
        -:   83:    /* Verifica se há vitória em linhas j */
       12:   84:    for (int j = 0; j <= 2; j++) {
       9*:   85:        if ((velha[j][0] == velha[j][1] && velha[j][1] == velha[j][2]) &&
    #####:   86:        (velha[j][0] == 1 || velha[j][0] == 2)) {
    #####:   87:            return velha[j][0];
        -:   88:        }
        -:   89:    }
        -:   90:    /* Verifica se há vitória em colunas i */
        8:   91:    for (int i = 0; i <= 2; i++) {
        7:   92:        if ((velha[0][i] == velha[1][i] && velha[1][i] == velha[2][i]) &&
        3:   93:        (velha[0][i] == 1 || velha[0][i] == 2)) {
        2:   94:            return velha[0][i];
        -:   95:        }
        -:   96:    }
        -:   97:    /* Verifica vitória na diagonal principal */
       1*:   98:    if ((velha[0][0] == velha[1][1] && velha[1][1] == velha[2][2]) &&
    #####:   99:    (velha[0][0] == 1 || velha[0][0] == 2)) {
    #####:  100:        return velha[0][0];
        -:  101:    }
        -:  102:    /* Verifica vitória na diagonal secundária */
        1:  103:    if ((velha[0][2] == velha[1][1] && velha[1][1] == velha[2][0]) &&
       1*:  104:    (velha[1][1] == 1 || velha[1][1] == 2)) {
        1:  105:        return velha[1][1];
        -:  106:    }
        -:  107:
        -:  108:    /* Caso nenhuma das condições anteriores seja satisfeita */
    #####:  109:    return -3;
        -:  110:}
